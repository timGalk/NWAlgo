import com.edu.nwalgo.backend.algo.AlignmentResult
import java.io.File
import java.io.FileOutputStream
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import com.lowagie.text.Document
import com.lowagie.text.Font
import com.lowagie.text.Paragraph
import com.lowagie.text.pdf.PdfWriter
import java.awt.BasicStroke
import java.awt.Color
import java.awt.Graphics2D
import java.awt.RenderingHints
import java.awt.geom.Path2D
import java.awt.image.BufferedImage
import javax.imageio.ImageIO

/**
 * Manages the generation and export of reports and visualizations related to sequence alignments.
 */
class DocumentManager {
    /**
     * Path to the directory where output results will be stored.
     * Used as the default location for saving generated files, logs, or other result data.
     */
// Constant for the output directory
    private val RESULTS_FOLDER = "results"

    /**
     * Ensures that the output directory specified by the `RESULTS_FOLDER` constant exists.
     * If the directory does not exist, it is created along with any necessary parent directories.
     */
// Helper function to ensure the folder exists
    fun ensureOutputDirectoryExists() {
        val outputDirectory = File(RESULTS_FOLDER)
        if (!outputDirectory.exists()) {
            outputDirectory.mkdirs()
        }
    }

    /**
     * Exports an alignment report to a PDF file. The report contains details about the alignment such as
     * aligned sequences, identity percentage, gap count, and final score.
     *
     * @param result The alignment result containing necessary data such as aligned sequences,
     *               identity percentage, gap count, and score.
     * @param filename The name of the output PDF file. If not provided, a timestamped filename is generated by default.
     */
    fun exportAlignmentReportToPDF(result: AlignmentResult, filename: String = "${generateTimestampedFilenamePDF()}") {
        ensureOutputDirectoryExists()

        // Export the PDF
        val filePath = "$RESULTS_FOLDER/$filename"
        val file = File(filePath)

        val document = Document()
        val writer = PdfWriter.getInstance(document, FileOutputStream(file))
        document.open()

        val titleFont = Font(Font.HELVETICA, 18f, Font.BOLD)
        val normalFont = Font(Font.HELVETICA, 12f)

        document.add(Paragraph("Needleman-Wunsch Alignment Report", titleFont))
        document.add(Paragraph(" "))

        document.add(Paragraph("Aligned Sequence 1:\n${result.alignedSeq1}", normalFont))
        document.add(Paragraph("Aligned Sequence 2:\n${result.alignedSeq2}", normalFont))
        document.add(Paragraph(" "))

        document.add(Paragraph("Identity: %.2f%%".format(result.identityPercent), normalFont))
        document.add(Paragraph("Gap Count: ${result.gapCount}", normalFont))
        document.add(Paragraph("Final Score: ${result.score}", normalFont))

        document.close()
        writer.close()
    }

    /**
     * Generates a filename with a timestamp appended to it, specifically for PDF files.
     *
     * @return A string representing the generated filename in the format "report_yyyy-MM-dd_HH-mm-ss.pdf".
     */
// Helper function to generate a timestamped filename
    fun generateTimestampedFilenamePDF(): String {
        val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss")
        return "report_${LocalDateTime.now().format(formatter)}.pdf"
    }

    /**
     * Renders a given scoring matrix along with associated sequence labels and path into a visual image.
     *
     * This function creates a BufferedImage representation of the matrix with labeled axes corresponding
     * to two input sequences. It highlights a specific path within the matrix and includes optional
     * arrows representing connections between the path cells.
     *
     * @param seq1 The first sequence, which will be represented vertically on the left side of the matrix.
     * @param seq2 The second sequence, which will be represented horizontally on the top side of the matrix.
     * @param matrix The scoring matrix represented as a 2D integer array.
     * @param path A list of cell coordinates (row, column) representing a path to be highlighted within the matrix.
     * @return A BufferedImage containing the rendered matrix with labels, path highlights, and arrows.
     */
    fun renderMatrixToImage(
        seq1: String,
        seq2: String,
        matrix: Array<IntArray>,
        path: List<Pair<Int, Int>>
    ): BufferedImage {
        val cellSize = 50
        val labelSpace = 2 * cellSize // space for labels (letters)
        val width = matrix[0].size * cellSize + labelSpace
        val height = matrix.size * cellSize + labelSpace

        val image = BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB)
        val g = image.createGraphics() as Graphics2D

        // Setting up fonts and rendering
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)
        g.font = java.awt.Font("Arial", java.awt.Font.PLAIN, 18)
        val letterFont = java.awt.Font("Arial", java.awt.Font.BOLD, 20)

        // Filling the background
        g.color = Color(255, 255, 255) // white color
        g.fillRect(0, 0, width, height)

        // Drawing the matrix
        for (i in matrix.indices) {
            for (j in matrix[i].indices) {
                val x = j * cellSize + labelSpace
                val y = i * cellSize + labelSpace

                val isPath = path.contains(i to j)
                g.color = if (isPath) Color(144, 238, 144) else Color(220, 220, 220) // green or gray
                g.fillRect(x, y, cellSize, cellSize)

                g.color = Color.BLACK
                g.drawRect(x, y, cellSize, cellSize)

                val value = matrix[i][j]
                val textX = x + cellSize / 4
                val textY = y + cellSize / 2 + 6
                g.drawString(value.toString(), textX, textY)
            }
        }

        // Drawing letters along the edges
        g.font = letterFont
        // On the left (seq1 vertically)
        for (i in seq1.indices) {
            val x = labelSpace / 2 - 10
            val y = (i + 1) * cellSize + labelSpace + cellSize / 2 - 10
            g.drawString(seq1[i].toString(), x, y)
        }
        // On the top (seq2 horizontally)
        for (j in seq2.indices) {
            val x = (j + 1) * cellSize + labelSpace + cellSize / 2 - 10
            val y = labelSpace / 2
            g.drawString(seq2[j].toString(), x, y)
        }

        // Drawing arrows for the path
        g.color = Color(0, 0, 255) // blue color for arrows
        g.stroke = BasicStroke(2f)
        for (i in 0 until path.size - 1) {
            val (fromI, fromJ) = path[i]
            val (toI, toJ) = path[i + 1]

            // Center of the starting and ending cells
            val fromX = fromJ * cellSize + labelSpace + cellSize / 2.0
            val fromY = fromI * cellSize + labelSpace + cellSize / 2.0
            val toX = toJ * cellSize + labelSpace + cellSize / 2.0
            val toY = toI * cellSize + labelSpace + cellSize / 2.0

            // Drawing the line
            g.drawLine(fromX.toInt(), fromY.toInt(), toX.toInt(), toY.toInt())

            // Drawing the arrow (triangle at the end)
            val arrowSize = 8.0
            val angle = Math.atan2(toY - fromY, toX - fromX)
            val arrow = Path2D.Double()
            arrow.moveTo(toX, toY)
            arrow.lineTo(
                toX - arrowSize * Math.cos(angle - Math.PI / 6),
                toY - arrowSize * Math.sin(angle - Math.PI / 6)
            )
            arrow.lineTo(
                toX - arrowSize * Math.cos(angle + Math.PI / 6),
                toY - arrowSize * Math.sin(angle + Math.PI / 6)
            )
            arrow.closePath()
            g.fill(arrow)
        }

        g.dispose()
        return image

    }
    /**
     * Exports a visual representation of a scoring matrix to a PNG file.
     * The method renders the matrix, sequence labels, and an aligned path (if provided) into an image
     * and saves it in the results directory.
     *
     * @param seq1 The first sequence (plotted vertically on the matrix).
     * @param seq2 The second sequence (plotted horizontally on the matrix).
     * @param matrix A 2D array representing the scoring or alignment matrix.
     * @param path A list of coordinate pairs representing the alignment path in the matrix.
     * @param filename The name of the output PNG file. If not specified, a timestamped filename is generated.
     */
    fun exportMatrixImageToFile(
        seq1: String,
        seq2: String,
        matrix: Array<IntArray>,
        path: List<Pair<Int, Int>>,
        filename: String = generateTimestampedFilenameImage()
    ) {
        ensureOutputDirectoryExists()

        val image = renderMatrixToImage(seq1, seq2, matrix, path)
        val filePath = "$RESULTS_FOLDER/$filename"
        val file = File(filePath)

        ImageIO.write(image, "png", file)
    }

    /**
     * Generates a timestamped filename for an image.
     *
     * The filename follows the format "matrix_yyyy-MM-dd_HH-mm-ss.png", where the timestamp
     * represents the current date and time at the moment the function is called.
     *
     * @return A string representing the generated timestamped filename.
     */
    fun generateTimestampedFilenameImage(): String {
        val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss")
        return "matrix_${LocalDateTime.now().format(formatter)}.png"
    }



}